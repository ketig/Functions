<!DOCTYPE html>
<html lang="ka">

<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>JavaScript ფუნქციები და Scope - მენტორის სესია</title>
    <link rel="stylesheet" href="styles.css">
</head>

<body>
    <div class="container">
        <header>
            <h1>🚀 JavaScript ფუნქციები და Scope</h1>
            <p class="subtitle">სრული მენტორის სესია - თეორია, მაგალითები და დავალებები</p>
            <div class="progress-bar">
                <div class="progress-fill" id="progressBar"></div>
            </div>
        </header>

        <div class="nav-tabs">
            <button class="nav-tab active" onclick="showSection('session-plan')">📋 სესიის გეგმა</button>
            <button class="nav-tab" onclick="showSection('theory')">🔧 ფუნქციების სახეები</button>
            <button class="nav-tab" onclick="showSection('scope-concepts')">🎯 Scope ცნებები</button>
            <button class="nav-tab" onclick="showSection('lexical-scope')">🔗 Lexical Scope</button>
            <button class="nav-tab" onclick="showSection('closures')">📦 Closures</button>
            <button class="nav-tab" onclick="showSection('modern-js')">✨ Modern JS Features</button>
            <button class="nav-tab" onclick="showSection('destructuring')">🔄 Destructuring</button>
            <button class="nav-tab" onclick="showSection('modules')">📁 Modules</button>
            <button class="nav-tab" onclick="showSection('dom-basics')">🌐 DOM Basics</button>
            <button class="nav-tab" onclick="showSection('script-loading')">⚡ Script Loading</button>
            <button class="nav-tab" onclick="showSection('dom-manipulation')">🎨 DOM Manipulation</button>
            <button class="nav-tab" onclick="showSection('event-handling')">🎪 Event Handling</button>
            <button class="nav-tab" onclick="showSection('practical-tasks')">💻 პრაქტიკული დავალებები</button>
            <button class="nav-tab" onclick="showSection('homework')">📝 სახლის დავალება</button>
            <button class="nav-tab" onclick="showSection('resources')">📚 რესურსები</button>
        </div>

        <!-- სესიის დაგეგმვა -->
        <div class="content-section active" id="session-plan">
            <h2>📋 სესიის გეგმა</h2>
            <div class="highlight">
                <h3>დრო: 3 საათი</h3>
                <ul>
                    <li><strong>0-30 წუთი:</strong> Scope ცნებები (function, block, lexical scope)</li>
                    <li><strong>30-60 წუთი:</strong> Scope Chain და Closure მექანიზმები</li>
                    <li><strong>60-90 წუთი:</strong> Modern JavaScript Features (rest/spread, destructuring)</li>
                    <li><strong>90-120 წუთი:</strong> Modules და DOM Basics</li>
                    <li><strong>120-150 წუთი:</strong> DOM Manipulation და Event Handling</li>
                    <li><strong>150-180 წუთი:</strong> პრაქტიკული დავალებები და Task Manager პროექტი</li>
                </ul>
            </div>
            <div class="topic-grid">
                <div class="topic-card">
                    <h3>🎯 Scope ცნებები (30 წუთი)</h3>
                    <ul>
                        <li>Function vs Block Scope</li>
                        <li>var, let, const განსხვავებები</li>
                        <li>Hoisting მექანიზმი</li>
                        <li>პრაქტიკული მაგალითები</li>
                    </ul>
                </div>
                <div class="topic-card">
                    <h3>🔗 Lexical Scope & Closures (30 წუთი)</h3>
                    <ul>
                        <li>Lexical Environment</li>
                        <li>Scope Chain მუშაობა</li>
                        <li>Closure კონცეფცია</li>
                        <li>Memory Management</li>
                    </ul>
                </div>
                <div class="topic-card">
                    <h3>✨ Modern JavaScript (30 წუთი)</h3>
                    <ul>
                        <li>Rest/Spread Operators</li>
                        <li>Array & Object Destructuring</li>
                        <li>ES6 Modules</li>
                        <li>Import/Export Syntax</li>
                    </ul>
                </div>
                <div class="topic-card">
                    <h3>🌐 DOM & Manipulation (30 წუთი)</h3>
                    <ul>
                        <li>DOM Tree Structure</li>
                        <li>Element Creation & Attributes</li>
                        <li>Query Selectors</li>
                        <li>Script Loading (defer/async)</li>
                    </ul>
                </div>
                <div class="topic-card">
                    <h3>🎪 Event Handling (30 წუთი)</h3>
                    <ul>
                        <li>Event Listeners</li>
                        <li>Event Bubbling/Capturing</li>
                        <li>preventDefault() მეთოდი</li>
                        <li>Common Events</li>
                    </ul>
                </div>
                <div class="topic-card">
                    <h3>💻 პრაქტიკული სამუშაო (30 წუთი)</h3>
                    <ul>
                        <li>Task Manager Project</li>
                        <li>Code Review</li>
                        <li>Best Practices</li>
                        <li>Q&A Session</li>
                    </ul>
                </div>
            </div>
        </div>

        <!-- Scope ცნებები -->
        <div class="content-section" id="scope-concepts">
            <h2>🎯 Scope ცნებები</h2>

            <div class="highlight">
                <strong>Scope</strong> განისაზღვრება როგორც ფარგლები, სადაც ცვლადები ხელმისაწვდომია და გამოიყენება.
            </div>

            <h3>📍 Function Scope</h3>
            <p>ცვლადები, რომლებიც გამოცხადებულია ფუნქციის შიგნით, ხელმისაწვდომია მხოლოდ ამ ფუნქციის შიგნით.</p>

            <pre><code>function example() {
    var functionScoped = "მე ვარ ფუნქციის ფარგლებში";
    
    if (true) {
        var alsoFunctionScoped = "მეც ფუნქციის ფარგლებში ვარ";
    }
    
    console.log(functionScoped); // მუშაობს
    console.log(alsoFunctionScoped); // მუშაობს - var hoisting!
}</code></pre>

            <h3>🔒 Block Scope</h3>
            <p>ცვლადები, რომლებიც გამოცხადებულია ბლოკის შიგნით <code>{}</code>, ხელმისაწვდომია მხოლოდ ამ ბლოკში.</p>

            <pre><code>function example() {
    if (true) {
        let blockScoped = "მე ვარ ბლოკის ფარგლებში";
        const alsoBlockScoped = "მეც ბლოკის ფარგლებში ვარ";
        
        console.log(blockScoped); // მუშაობს
    }
    
    // console.log(blockScoped); // ReferenceError!
    // console.log(alsoBlockScoped); // ReferenceError!
}</code></pre>

            <h3>⚡ var vs let vs const</h3>
            <div class="topic-grid">
                <div class="topic-card">
                    <h4>var</h4>
                    <ul>
                        <li>Function scoped</li>
                        <li>Hoisting ხდება</li>
                        <li>Re-declaration შესაძლებელია</li>
                        <li>Re-assignment შესაძლებელია</li>
                    </ul>
                </div>
                <div class="topic-card">
                    <h4>let</h4>
                    <ul>
                        <li>Block scoped</li>
                        <li>Temporal Dead Zone</li>
                        <li>Re-declaration არ შეიძლება</li>
                        <li>Re-assignment შესაძლებელია</li>
                    </ul>
                </div>
                <div class="topic-card">
                    <h4>const</h4>
                    <ul>
                        <li>Block scoped</li>
                        <li>Temporal Dead Zone</li>
                        <li>Re-declaration არ შეიძლება</li>
                        <li>Re-assignment არ შეიძლება</li>
                    </ul>
                </div>
            </div>
        </div>

        <!-- Lexical Scope და Scope Chain -->
        <div class="content-section" id="lexical-scope">
            <h2>🔗 Lexical Scope და Scope Chain</h2>

            <h3>Lexical Scope (ლექსიკური Scope)</h3>
            <p>JavaScript იყენებს lexical scoping-ს, რაც ნიშნავს რომ ფუნქციის scope განისაზღვრება იქ, სადაც ის წერია
                კოდში, არა იქ სადაც მას იძახებენ.</p>

            <pre><code>let global = "გლობალური მნიშვნელობა";

function outsideFunction() {
    let outside = "გარე ფუნქციის მნიშვნელობა";
    
    function insideFunction() {
        let inside = "შიდა ფუნქციის მნიშვნელობა";
        
        // ყველა მშობელი scope-ის ხელმისაწვდომია
        console.log("შიდა:", inside);
        console.log("გარე:", outside);
        console.log("გლობალური:", global);
        
        function mostInsideFunction() {
            console.log("ყველაზე შიდა ხედავს ყველაფერს:");
            console.log(inside, outside, global);
        }
        
        return mostInsideFunction;
    }
    
    return insideFunction;
}

const inside = outsideFunction();
const insideValue = inside();
insideValue();</code></pre>

            <h3>Scope Chain (Scope-ების ჯაჭვი)</h3>
            <p>როდესაც JavaScript ეძებს ცვლადს, ის იწყებს მიმდინარე scope-იდან და მიდის მშობელ scope-ებში მანამ,
                სანამ ნაპოვნი არ იქნება ან გლობალური scope არ დასრულდება.</p>

            <pre><code>let a = "გლობალური a";
let b = "გლობალური b";
let c = "გლობალური c";

function დონე1() {
    let a = "დონე1 a"; // shadows გლობალური a
    let b = "დონე1 b"; // shadows გლობალური b
    
    function დონე2() {
        let a = "დონე2 a"; // shadows ყველა a
        
        function დონე3() {
            // არ აქვს საკუთარი a, b, c
            console.log("a:", a); // იპოვის დონე2-ის a
            console.log("b:", b); // იპოვის დონე1-ის b  
            console.log("c:", c); // იპოვის გლობალურ c
        }
        
        დონე3();
    }
    
    დონე2();
}

დონე1();

// Scope chain: დონე3 -> დონე2 -> დონე1 -> Global</code></pre>
        </div>

        <!-- Closures -->
        <div class="content-section" id="closures">
            <h2>🔒 Closure (ჩაკეტვა)</h2>

            <p>Closure არის JavaScript-ის ერთ-ერთი ყველაზე ძლიერი და მნიშვნელოვანი კონცეფცია. ეს ფუნქციის უნარია
                "ახსოვდეს" ის scope, სადაც ის შეიქმნა, მაშინაც კი, როდესაც ამ scope-იდან გასვლის შემდეგ იყენება.</p>

            <div class="highlight">
                <strong>განმარტება:</strong> Closure წარმოიქმნება მაშინ, როდესაც შიდა ფუნქცია ხვდება გარე ფუნქციის
                ცვლადებს, მაშინაც კი, როდესაც გარე ფუნქცია უკვე დასრულდა.
            </div>

            <h3>ძირითადი Closure მაგალითი</h3>
            <pre><code>function outsideFunction(x) {
    // გარე ფუნქციის ცვლადი
    let გარე_ცვლადი = x;
    
    // შიდა ფუნქცია რომელიც closure ქმნის
    function შიდა_ფუნქცია(y) {
        // შეუძლია წვდომა გარე ფუნქციის ცვლადებზე
        return გარე_ცვლადი + y;
    }
    
    // შიდა ფუნქციის დაბრუნება
    return შიდა_ფუნქცია;
}

// closure-ის შექმნა
const მყო_ფუნქცია = outsideFunction(10);

// closure-ის გამოყენება
console.log(მყო_ფუნქცია(5)); // 15

// თითოეული closure შეიცავს უნიკალურ გარემოს
const სხვა_ფუნქცია = outsideFunction(20);
console.log(სხვა_ფუნქცია(5)); // 25</code></pre>

            <h3>Counter მაგალითი Closure-ით</h3>
            <pre><code>function createCounter() {
    let count = 0;
    
    return {
        increment: function() {
            count++;
            return count;
        },
        decrement: function() {
            count--;
            return count;
        },
        getValue: function() {
            return count;
        },
        reset: function() {
            count = 0;
            return count;
        }
    };
}

// კაუნტერის შექმნა
const counter1 = createCounter();
const counter2 = createCounter();

// პირველი კაუნტერი
console.log(counter1.increment()); // 1
console.log(counter1.increment()); // 2
console.log(counter1.getValue()); // 2

// მეორე კაუნტერი (დამოუკიდებელი)
console.log(counter2.increment()); // 1
console.log(counter2.getValue()); // 1</code></pre>
        </div>

        <!-- Modern JS Features -->
        <div class="content-section" id="modern-js">
            <h2>✨ Modern JavaScript Features</h2>

            <h3>Rest Parameter (დანარჩენი პარამეტრები)</h3>
            <p>Rest parameter-ი საშუალებას გვაძლევს ფუნქციაში მივიღოთ რაოდენობით განუსაზღვრელი არგუმენტები მასივის
                სახით.</p>

            <pre><code>function sum(...numbers) {
    return numbers.reduce((total, num) => total + num, 0);
}

console.log(sum(1, 2, 3, 4)); // 10
console.log(sum(5, 10)); // 15

function greetAll(greeting, ...names) {
    return names.map(name => `${greeting}, ${name}!`);
}

console.log(greetAll("გამარჯობა", "ანა", "ნიკა", "მარიამი"));
// ["გამარჯობა, ანა!", "გამარჯობა, ნიკა!", "გამარჯობა, მარიამი!"]</code></pre>

            <h3>Spread Operator (გავრცელების ოპერატორი)</h3>
            <p>Spread operator იყენება მასივების ან ობიექტების "გაშლისთვის".</p>

            <pre><code>// მასივებთან მუშაობა
const arr1 = [1, 2, 3];
const arr2 = [4, 5, 6];
const combined = [...arr1, ...arr2]; // [1, 2, 3, 4, 5, 6]

// მასივის კოპირება
const original = [1, 2, 3];
const copy = [...original]; // ახალი მასივი

// ფუნქციის არგუმენტებად გადაცემა
const numbers = [1, 2, 3];
console.log(Math.max(...numbers)); // 3

// ობიექტებთან მუშაობა
const obj1 = { a: 1, b: 2 };
const obj2 = { c: 3, d: 4 };
const merged = { ...obj1, ...obj2 }; // { a: 1, b: 2, c: 3, d: 4 }

// ობიექტის განახლება
const person = { name: "ანა", age: 25 };
const updatedPerson = { ...person, age: 26 }; // { name: "ანა", age: 26 }</code></pre>
        </div>

        <!-- Destructuring -->
        <div class="content-section" id="destructuring">
            <h2>🔄 Destructuring</h2>

            <h3>Array Destructuring (მასივის დეკონსტრუქცია)</h3>
            <p>მასივის destructuring საშუალებას გვაძლევს ერთდროულად რამდენიმე ცვლადს მივანიჭოთ მნიშვნელობები მასივიდან.
            </p>

            <pre><code>const colors = ["წითელი", "ლურჯი", "მწვანე", "ყვითელი"];

// ძირითადი destructuring
const [first, second, third] = colors;
console.log(first); // "წითელი"
console.log(second); // "ლურჯი"

// რამდენიმე ელემენტის გამოტოვება
const [firstColor, , thirdColor] = colors;
console.log(firstColor); // "წითელი"
console.log(thirdColor); // "მწვანე"

// Rest operator-ით
const [primary, ...secondary] = colors;
console.log(primary); // "წითელი"
console.log(secondary); // ["ლურჯი", "მწვანე", "ყვითელი"]

// Default values
const [a, b, c, d, e = "უცნობი"] = colors;
console.log(e); // "ყვითელი" (თუ არსებობს) ან "უცნობი"</code></pre>

            <h3>Object Destructuring (ობიექტის დეკონსტრუქცია)</h3>

            <pre><code>const person = {
    name: "ნიკა",
    age: 25,
    city: "თბილისი",
    profession: "დეველოპერი"
};

// ძირითადი destructuring
const { name, age } = person;
console.log(name); // "ნიკა"
console.log(age);  // 25

// ახალი სახელების მინიჭება
const { name: სახელი, age: ასაკი } = person;
console.log(სახელი); // "ნიკა"
console.log(ასაკი);  // 25

// Default values
const { name, country = "საქართველო" } = person;
console.log(country); // "საქართველო"

// Nested destructuring
const student = {
    info: {
        name: "მარიამი",
        grade: 12
    },
    subjects: ["მათემატიკა", "ისტორია"]
};

const { info: { name: studentName, grade }, subjects: [firstSubject] } = student;
console.log(studentName); // "მარიამი"
console.log(grade); // 12
console.log(firstSubject); // "მათემატიკა"</code></pre>

            <h3>Function Parameters Destructuring</h3>

            <pre><code>// ობიექტის destructuring function parameters-ში
function createUser({ name, email, age = 18 }) {
    return {
        name,
        email,
        age,
        id: Date.now()
    };
}

const userData = { name: "ანა", email: "ana@example.com" };
const user = createUser(userData);
console.log(user); // { name: "ანა", email: "ana@example.com", age: 18, id: ... }

// მასივის destructuring function parameters-ში
function processCoordinates([x, y, z = 0]) {
    return { x, y, z };
}

const coordinates = [10, 20];
console.log(processCoordinates(coordinates)); // { x: 10, y: 20, z: 0 }</code></pre>
        </div>

        <!-- Modules -->
        <div class="content-section" id="modules">
            <h2>📁 ES6 Modules</h2>

            <p>მოდულები საშუალებას გვაძლევს კოდი დავყოთ ცალკეულ ფაილებში და მათ შორის გავაზიაროთ ფუნქციონალი.</p>

            <h3>Export (ექსპორტი)</h3>

            <pre><code>// math-utils.js
export function add(a, b) {
    return a + b;
}

export function subtract(a, b) {
    return a - b;
}

export const PI = 3.14159;

// Default export
export default function multiply(a, b) {
    return a * b;
}

// ან ყველაფერი ერთად
const divide = (a, b) => a / b;
const GRAVITY = 9.81;

export { divide, GRAVITY };</code></pre>

            <h3>Import (იმპორტი)</h3>

            <pre><code>// main.js
import multiply, { add, subtract, PI } from './math-utils.js';

console.log(multiply(5, 3)); // 15
console.log(add(2, 3)); // 5
console.log(PI); // 3.14159

// ყველაფრის იმპორტი
import * as MathUtils from './math-utils.js';
console.log(MathUtils.add(2, 3)); // 5
console.log(MathUtils.default(4, 5)); // 20 (default export)

// Aliasing
import { add as plus, subtract as minus } from './math-utils.js';
console.log(plus(5, 3)); // 8
console.log(minus(10, 4)); // 6</code></pre>

            <h3>Module Pattern მაგალითი</h3>

            <pre><code>// user-service.js
let users = [];
let currentId = 1;

function validateUser(user) {
    return user && user.name && user.email;
}

export function addUser(userData) {
    if (!validateUser(userData)) {
        throw new Error('Invalid user data');
    }
    
    const user = {
        id: currentId++,
        ...userData,
        createdAt: new Date()
    };
    
    users.push(user);
    return user;
}

export function getUserById(id) {
    return users.find(user => user.id === id);
}

export function getAllUsers() {
    return [...users]; // return copy, not original
}

export function removeUser(id) {
    const index = users.findIndex(user => user.id === id);
    if (index !== -1) {
        return users.splice(index, 1)[0];
    }
    return null;
}</code></pre>
        </div>

        <!-- DOM Basics -->
        <div class="content-section" id="dom-basics">
            <h2>🌐 Document Object Model (DOM)</h2>

            <p>DOM არის HTML დოკუმენტის პროგრამული წარმოდგენა, რომელიც საშუალებას გვაძლევს JavaScript-ით მანიპულირება
                გავუწიოთ HTML ელემენტებს.</p>

            <h3>DOM Tree Structure</h3>
            <div class="highlight">
                HTML დოკუმენტი წარმოდგენილია ხის სტრუქტურად:
                <ul>
                    <li><strong>Document node:</strong> root node</li>
                    <li><strong>Element nodes:</strong> HTML ტეგები</li>
                    <li><strong>Text nodes:</strong> ტექსტური შინაარსი</li>
                    <li><strong>Attribute nodes:</strong> ელემენტების ატრიბუტები</li>
                </ul>
            </div>

            <pre><code>&lt;!-- HTML სტრუქტურა --&gt;
&lt;html&gt;
  &lt;head&gt;
    &lt;title&gt;ჩემი გვერდი&lt;/title&gt;
  &lt;/head&gt;
  &lt;body&gt;
    &lt;h1 id="title"&gt;მთავარი სათაური&lt;/h1&gt;
    &lt;p class="description"&gt;ეს არის აღწერა&lt;/p&gt;
    &lt;ul&gt;
      &lt;li&gt;პირველი ელემენტი&lt;/li&gt;
      &lt;li&gt;მეორე ელემენტი&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/body&gt;
&lt;/html&gt;</code></pre>

            <h3>DOM Navigation (ნავიგაცია)</h3>

            <pre><code>// Parent/Child ურთიერთობები
const element = document.getElementById('title');

// მშობელი ელემენტი
console.log(element.parentNode); // body
console.log(element.parentElement); // body

// შვილი ელემენტები
const body = document.body;
console.log(body.children); // HTML Collection
console.log(body.childNodes); // NodeList (includes text nodes)
console.log(body.firstElementChild); // პირველი element child
console.log(body.lastElementChild); // ბოლო element child

// ძმა ელემენტები
const h1 = document.querySelector('h1');
console.log(h1.nextElementSibling); // შემდეგი ელემენტი
console.log(h1.previousElementSibling); // წინა ელემენტი</code></pre>
        </div>

        <!-- Script Loading -->
        <div class="content-section" id="script-loading">
            <h2>⚡ Script Loading - Defer და Async</h2>

            <h3>Default Behavior (ჩვეულებრივი ქცევა)</h3>
            <p>ჩვეულებრივ, script ტეგები ბლოკავენ HTML-ის parsing-ს სანამ script ჩამოტვირთვა და შესრულება არ დასრულდება.
            </p>

            <pre><code>&lt;script src="script.js"&gt;&lt;/script&gt;
&lt;!-- HTML parsing ელოდება script-ის დასრულებას --&gt;</code></pre>

            <h3>Defer Attribute</h3>
            <div class="highlight">
                <ul>
                    <li>Script ჩამოიტვირთება HTML parsing-ის პარალელურად</li>
                    <li>შესრულდება მხოლოდ მას შემდეგ, რაც HTML parsing დასრულდება</li>
                    <li>defer script-ები შესრულდება თანმიმდევრობით</li>
                    <li>იდეალურია DOM manipulation-ისთვის</li>
                </ul>
            </div>

            <pre><code>&lt;script src="script1.js" defer&gt;&lt;/script&gt;
&lt;script src="script2.js" defer&gt;&lt;/script&gt;
&lt;!-- script1 შესრულდება script2-ის წინ --&gt;</code></pre>

            <h3>Async Attribute</h3>
            <div class="highlight">
                <ul>
                    <li>Script ჩამოიტვირთება HTML parsing-ის პარალელურად</li>
                    <li>შესრულდება იმ წუთად, როცა ჩამოიტვირთება (შეიძლება HTML parsing-ს შეწყვიტოს)</li>
                    <li>async script-ების შესრულების თანმიმდევრობა არ არის გარანტირებული</li>
                    <li>იდეალურია analytics ან independent script-ებისთვის</li>
                </ul>
            </div>

            <pre><code>&lt;script src="analytics.js" async&gt;&lt;/script&gt;
&lt;script src="ads.js" async&gt;&lt;/script&gt;
&lt;!-- შესრულების თანმიმდევრობა არ არის გარანტირებული --&gt;</code></pre>

            <h3>შედარებითი ცხრილი</h3>
            <div class="topic-grid">
                <div class="topic-card">
                    <h4>Default</h4>
                    <ul>
                        <li>HTML parsing ბლოკირებულია</li>
                        <li>Sequential execution</li>
                        <li>Blocking behavior</li>
                    </ul>
                </div>
                <div class="topic-card">
                    <h4>Defer</h4>
                    <ul>
                        <li>Non-blocking download</li>
                        <li>Executes after HTML parsing</li>
                        <li>Maintains order</li>
                    </ul>
                </div>
                <div class="topic-card">
                    <h4>Async</h4>
                    <ul>
                        <li>Non-blocking download</li>
                        <li>Executes immediately</li>
                        <li>No order guarantee</li>
                    </ul>
                </div>
            </div>
        </div>

        <!-- DOM Manipulation -->
        <div class="content-section" id="dom-manipulation">
            <!-- ??? -->
        </div>

        <!-- Event Handling -->
        <div class="content-section" id="event-handling">
            <!-- ??? -->
        </div>

        <!-- პრაქტიკული დავალებები -->
        <div class="content-section" id="practical-tasks">
            <h2>💻 პრაქტიკული დავალებები</h2>
            <p>ამ სექციაში განვიხილავთ რამდენიმე პრაქტიკულ მაგალითს, რომლებიც დაგეხმარებათ უკეთ გაიგოთ ფუნქციები,
                scope და closure-ები რეალურ სამყაროში.</p>
            <br>

            <h2>💡 პრაქტიკული მაგალითები</h2>

            <h3>1. Event Handlers და Closures</h3>
            <div class="code-container">
                <div class="code-header">Event Handler მაგალითი</div>
                <pre>
function ღილაკების_შექმნა() {
    const container = document.getElementById('buttonContainer');
    
    for (let i = 1; i <= 3; i++) {
        const button = document.createElement('button');
        button.textContent = `ღილაკი ${i}`;
        
        // Closure იცავს i-ის მნიშვნელობას თითოეული ღილაკისთვის
        button.addEventListener('click', function() {
            alert(`დააჭირეთ ღილაკი ნომერი ${i}`);
        });
        
        container.appendChild(button);
    }
}

// var-ის პრობლემა (ძველი კოდი)
function პრობლემური_ღილაკები() {
    const container = document.getElementById('problemButtons');
    
    for (var j = 1; j <= 3; j++) {
        const button = document.createElement('button');
        button.textContent = `პრობლემური ${j}`;
        
        // ყველა ღილაკი იჩენებს ბოლო მნიშვნელობას (4)
        button.addEventListener('click', function() {
            alert(`j-ის მნიშვნელობაა: ${j}`); // ყოველთვის 4
        });
        
        container.appendChild(button);
    }
}
                    </pre>
            </div>

            <h3>2. Memoization Closure-ით</h3>
            <div class="code-container">
                <div class="code-header">Memoization მაგალითი</div>
                <pre>
function მემოიზირებული_ფუნქცია() {
    const cache = {};
    
    return function(n) {
        // თუ შედეგი უკვე არის cache-ში
        if (cache[n] !== undefined) {
            console.log(`Cache-იდან: ${n}`);
            return cache[n];
        }
        
        // ფიბონაჩის რიცხვის გამოთვლა
        console.log(`გამოთვლა: ${n}`);
        let result;
        
        if (n <= 1) {
            result = n;
        } else {
            result = მემოიზირებული_ფუნქცია_რეკ(n - 1) + მემოიზირებული_ფუნქცია_რეკ(n - 2);
        }
        
        // შედეგის შენახვა cache-ში
        cache[n] = result;
        return result;
    };
}

const ფიბონაჩი = მემოიზირებული_ფუნქცია();

// პირველი გამოძახება - გამოთვლას
console.log(ფიბონაჩი(10)); // 55

// მეორე გამოძახება - cache-იდან
console.log(ფიბონაჩი(10)); // 55 (cache-იდან)
                    </pre>
            </div>

            <h3>3. Factory Functions</h3>
            <div class="code-container">
                <div class="code-header">Factory Function მაგალითი</div>
                <pre>
function ადამიანის_ქარხანა(სახელი, ასაკი) {
    let პრივატული_ინფო = {
        დაბადების_წელი: new Date().getFullYear() - ასაკი,
        სიკვდილობა: false
    };
    
    return {
        სახელი: სახელი,
        
        ასაკის_მიღება: function() {
            const მიმდინარე_წელი = new Date().getFullYear();
            return მიმდინარე_წელი - პრივატული_ინფო.დაბადების_წელი;
        },
        
        დაბადების_წლის_მიღება: function() {
            return პრივატული_ინფო.დაბადების_წელი;
        },
        
        მისალმება: function() {
            return `გამარჯობა, მე ვარ ${this.სახელი} და ${this.ასაკის_მიღება()} წლის ვარ`;
        },
        
        ასაკის_შეცვლა: function(ახალი_ასაკი) {
            const მიმდინარე_წელი = new Date().getFullYear();
            პრივატული_ინფო.დაბადების_წელი = მიმდინარე_წელი - ახალი_ასაკი;
        }
    };
}

// Factory function-ის გამოყენება
const ნინო = ადამიანის_ქარხანა("ნინო", 25);
const გიორგი = ადამიანის_ქარხანა("გიორგი", 30);

console.log(ნინო.მისალმება()); // გამარჯობა, მე ვარ ნინო და 25 წლის ვარ
console.log(გიორგი.მისალმება()); // გამარჯობა, მე ვარ გიორგი და 30 წლის ვარ

// პრივატულ ინფორმაციას ვერ მივედით პირდაპირ
// console.log(ნინო.დაბადების_წელი); // undefined
console.log(ნინო.დაბადების_წლის_მიღება()); // მუშაობს
                    </pre>
            </div>
        </div>

        <!-- დავალება -->
        <div class="content-section" id="homework">
            <h2>🏠 საშინაო დავალება</h2>

            <div class="task">
                <h3>დავალება 1: ფუნქციების შედარება (10 ქულა)</h3>
                <p>შექმენით ერთი და იგივე ფუნქცია სამი განსხვავებული გზით:</p>
                <ul>
                    <li>Function Declaration</li>
                    <li>Function Expression</li>
                    <li>Arrow Function</li>
                </ul>
                <p><strong>ფუნქცია:</strong> მიიღოს რიცხვების მასივი და დააბრუნოს მხოლოდ ლუწი რიცხვების ჯამი.</p>
                <p><strong>მაგალითი:</strong> [1, 2, 3, 4, 5, 6] → 12 (2+4+6)</p>
            </div>

            <div class="task">
                <h3>დავალება 2: Scope-ების ანალიზი (15 ქულა)</h3>
                <p>გაანალიზეთ მოცემული კოდი და ახსენით რა იქნება გამოსულება console.log-ებისთვის და რატომ:</p>
                <div class="code-container">
                    <pre>
var a = 1;
let b = 2;
const c = 3;

function ტესტი() {
    console.log(a, b, c); // რა იქნება აქ?
    
    var a = 10;
    let b = 20;
    
    if (true) {
        var a = 100;
        let b = 200;
        const c = 300;
        console.log(a, b, c); // რა იქნება აქ?
    }
    
    console.log(a, b, c); // რა იქნება აქ?
}

ტესტი();
console.log(a, b, c); // რა იქნება აქ?
                        </pre>
                </div>
            </div>

            <div class="task">
                <h3>დავალება 3: Closure Calculator (20 ქულა)</h3>
                <p>შექმენით closure-ის გამოყენებით კალკულატორი, რომელსაც შეუძლია:</p>
                <ul>
                    <li>რიცხვების დამახსოვრება</li>
                    <li>მათემატიკური ოპერაციების შესრულება (+, -, *, /)</li>
                    <li>ისტორიის დამახსოვრება</li>
                    <li>გასუფთავება</li>
                </ul>
                <p><strong>მაგალითი გამოყენება:</strong></p>
                <div class="code-container">
                    <pre>
const კალკ = კალკულატორი();
კალკ.დამატება(5);
კალკ.გამრავლება(3);
კალკ.შედეგი(); // 15
კალკ.ისტორია(); // ["0 + 5 = 5", "5 * 3 = 15"]
                        </pre>
                </div>
            </div>

            <div class="task">
                <h3>დავალება 4: Module Pattern (25 ქულა)</h3>
                <p>შექმენით სტუდენტების მენეჯმენტის მოდული closure და module pattern-ის გამოყენებით. მოდულს უნდა
                    შეეძლოს:</p>
                <ul>
                    <li>სტუდენტის დამატება (სახელი, ასაკი, შეფასებები)</li>
                    <li>სტუდენტის ძებნა სახელით</li>
                    <li>შეფასების დამატება სტუდენტისთვის</li>
                    <li>საშუალო ქულის გამოთვლა</li>
                    <li>ყველა სტუდენტის სია</li>
                    <li>სტუდენტის წაშლა</li>
                </ul>
                <p>მნიშვნელოვანია რომ სტუდენტების მონაცემები იყოს პრივატული და მათზე წვდომა მხოლოდ მოდულის მეთოდების
                    მეშვეობით იყოს შესაძლებელი.</p>
            </div>

            <div class="task">
                <h3>დავალება 5: Advanced Closure (30 ქულა)</h3>
                <p>შექმენით "Task Queue" სისტემა closure-ების გამოყენებით რომელსაც შეუძლია:</p>
                <ul>
                    <li>დავალების დამატება (სახელი, პრიორიტეტი, ფუნქცია)</li>
                    <li>დავალების შესრულება პრიორიტეტის მიხედვით</li>
                    <li>დავალების გადადება</li>
                    <li>შესრულებული დავალების ისტორია</li>
                    <li>მომლოდინე დავალების ნახვა</li>
                </ul>
                <p>დამატებითი ფუნქციები:</p>
                <ul>
                    <li>ავტომატური შესრულება timeout-ით</li>
                    <li>დავალების ჯგუფების შექმნა</li>
                    <li>პროგრესის თვალყურის დევნება</li>
                </ul>
            </div>

            <div style="background: rgba(255,255,255,0.2); padding: 1.5rem; border-radius: 10px; margin-top: 2rem;">
                <h3>📝 შეფასების კრიტერიუმები:</h3>
                <ul>
                    <li><strong>სისწორე (40%):</strong> კოდი მუშაობს ყველა ტესტ კეისზე</li>
                    <li><strong>ხარისხი (30%):</strong> სუფთა, წაკითხვადი კოდი</li>
                    <li><strong>ახსნა (20%):</strong> კომენტარები და ახსნა იმისა თუ როგორ მუშაობს closure</li>
                    <li><strong>შემოქმედება (10%):</strong> დამატებითი ფუნქციონალი</li>
                </ul>
            </div>

            <div
                style="background: rgba(255,255,255,0.1); padding: 1rem; border-radius: 8px; margin-top: 1rem; text-align: center;">
                <p><strong>ვადა:</strong> 1 კვირა | <strong>ჩაბარება:</strong> GitHub Repository + ცოცხალი დემო</p>
            </div>
        </div>

        <!-- დამატებითი რესურსები -->
        <div class="content-section" id="resources">
            <h2>📚 დამატებითი რესურსები</h2>

            <h3>რეკომენდებული წიგნები:</h3>
            <ul>
                <li>"You Don't Know JS" - Kyle Simpson</li>
                <li>"JavaScript: The Good Parts" - Douglas Crockford</li>
                <li>"Eloquent JavaScript" - Marijn Haverbeke</li>
            </ul>

            <h3>ონლაინ რესურსები:</h3>
            <ul>
                <li>MDN Web Docs - JavaScript Guide</li>
                <li>JavaScript.info - The Modern JavaScript Tutorial</li>
                <li>freeCodeCamp - JavaScript Algorithms</li>
            </ul>

            <h3>პრაქტიკისთვის:</h3>
            <ul>
                <li>Codewars - JavaScript challenges</li>
                <li>LeetCode - Programming problems</li>
                <li>HackerRank - JavaScript domain</li>
            </ul>
        </div>
    </div>

    <script src="script.js"></script>
</body>

</html>